package sm9curve

import (
    "testing"
    "crypto/rand"
)

func TestG1AddNeg(t *testing.T) {
    g1, g2 := &G1{}, &G1{}

    g1.Neg(Gen1)
    g2.Add(g1, Gen1)
    if !g2.p.IsInfinity() {
        t.Fail()
    }
    g3 := &G1{}
    g3.Set(Gen1)
    if !g3.Equal(Gen1) {
        t.Fail()
    }
}

type g1BaseMultTest struct {
    k string
}

var baseMultTests = []g1BaseMultTest{
    {
        "112233445566778899",
    },
    {
        "112233445566778899112233445566778899",
    },
    {
        "6950511619965839450988900688150712778015737983940691968051900319680",
    },
    {
        "13479972933410060327035789020509431695094902435494295338570602119423",
    },
    {
        "13479971751745682581351455311314208093898607229429740618390390702079",
    },
    {
        "13479972931865328106486971546324465392952975980343228160962702868479",
    },
    {
        "11795773708834916026404142434151065506931607341523388140225443265536",
    },
    {
        "784254593043826236572847595991346435467177662189391577090",
    },
    {
        "13479767645505654746623887797783387853576174193480695826442858012671",
    },
    {
        "205688069665150753842126177372015544874550518966168735589597183",
    },
    {
        "13479966930919337728895168462090683249159702977113823384618282123295",
    },
    {
        "50210731791415612487756441341851895584393717453129007497216",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368041",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368042",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368043",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368044",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368045",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368046",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368047",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368048",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368049",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368050",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368051",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368052",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368053",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368054",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368055",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368056",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368057",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368058",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368059",
    },
    {
        "26959946667150639794667015087019625940457807714424391721682722368060",
    },
}

func TestG1ScaleMult(t *testing.T) {
    k, e, err := RandomG1(rand.Reader)
    if err != nil {
        t.Fatal(err)
    }
    e.p.MakeAffine()

    e2, e3 := &G1{}, &G1{}

    if e2.p == nil {
        e2.p = &curvePoint{}
    }

    e2.p.Mul(curveGen, k)
    e2.p.MakeAffine()

    if !e.Equal(e2) {
        t.Errorf("not same")
    }

    _, err = e3.ScalarMult(Gen1, NormalizeScalar(k.Bytes()))
    if err != nil {
        t.Fatal(err)
    }
    e3.p.MakeAffine()

    if !e.Equal(e3) {
        t.Errorf("not same")
    }
}

func Test_G1MarshalCompressed(t *testing.T) {
    e, e2 := &G1{}, &G1{}
    ret := e.MarshalCompressed()
    _, err := e2.UnmarshalCompressed(ret)
    if err != nil {
        t.Fatal(err)
    }
    if !e2.p.IsInfinity() {
        t.Errorf("not same")
    }
    e.p.Set(curveGen)
    ret = e.MarshalCompressed()
    _, err = e2.UnmarshalCompressed(ret)
    if err != nil {
        t.Fatal(err)
    }
    if e2.p.x != e.p.x || e2.p.y != e.p.y || e2.p.z != e.p.z {
        t.Errorf("not same")
    }
    e.p.Neg(e.p)
    ret = e.MarshalCompressed()
    _, err = e2.UnmarshalCompressed(ret)
    if err != nil {
        t.Fatal(err)
    }
    if e2.p.x != e.p.x || e2.p.y != e.p.y || e2.p.z != e.p.z {
        t.Errorf("not same")
    }
}
