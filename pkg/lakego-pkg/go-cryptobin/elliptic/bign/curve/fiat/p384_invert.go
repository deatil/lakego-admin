// Code generated by generate.go. DO NOT EDIT.
package fiat

// Invert sets e = 1/x, and returns e.
//
// If x == 0, Invert returns e = 0.
func (e *P384Element) Invert(x *P384Element) *P384Element {
    // Inversion is implemented as exponentiation with exponent p âˆ’ 2.
    // The sequence of 14 multiplications and 383 squarings is derived from the
    // following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.
    //
    //	_10       = 2*1
    //	_11       = 1 + _10
    //	_1100     = _11 << 2
    //	_1111     = _11 + _1100
    //	_11110000 = _1111 << 4
    //	_11111111 = _1111 + _11110000
    //	x16       = _11111111 << 8 + _11111111
    //	x20       = x16 << 4 + _1111
    //	x22       = x20 << 2 + _11
    //	x44       = x22 << 22 + x22
    //	x88       = x44 << 44 + x44
    //	x176      = x88 << 88 + x88
    //	x352      = x176 << 176 + x176
    //	x374      = x352 << 22 + x22
    //	x375      = 2*x374 + 1
    //	return      (x375 << 3 + _11) << 6 + 1
    //
    var z = new(P384Element).Set(e)
    var t0 = new(P384Element)
    var t1 = new(P384Element)
    var t2 = new(P384Element)

    z.Square(x)
    z.Mul(x, z)
    t0.Square(z)
    for s := 1; s < 2; s++ {
        t0.Square(t0)
    }
    t0.Mul(z, t0)
    t1.Square(t0)
    for s := 1; s < 4; s++ {
        t1.Square(t1)
    }
    t1.Mul(t0, t1)
    t2.Square(t1)
    for s := 1; s < 8; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    for s := 0; s < 4; s++ {
        t1.Square(t1)
    }
    t0.Mul(t0, t1)
    for s := 0; s < 2; s++ {
        t0.Square(t0)
    }
    t0.Mul(z, t0)
    t1.Square(t0)
    for s := 1; s < 22; s++ {
        t1.Square(t1)
    }
    t1.Mul(t0, t1)
    t2.Square(t1)
    for s := 1; s < 44; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 88; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 176; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    for s := 0; s < 22; s++ {
        t1.Square(t1)
    }
    t0.Mul(t0, t1)
    t0.Square(t0)
    t0.Mul(x, t0)
    for s := 0; s < 3; s++ {
        t0.Square(t0)
    }
    z.Mul(z, t0)
    for s := 0; s < 6; s++ {
        z.Square(z)
    }
    z.Mul(x, z)
    return e.Set(z)
}
