// Code generated by generate.go. DO NOT EDIT.
package fiat

// Invert sets e = 1/x, and returns e.
//
// If x == 0, Invert returns e = 0.
func (e *P512Element) Invert(x *P512Element) *P512Element {
    // Inversion is implemented as exponentiation with exponent p âˆ’ 2.
    // The sequence of 16 multiplications and 511 squarings is derived from the
    // following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.
    //
    //	_10      = 2*1
    //	_100     = 2*_10
    //	_101     = 1 + _100
    //	_111     = _10 + _101
    //	_1110    = 2*_111
    //	_1110000 = _1110 << 3
    //	_1111110 = _1110 + _1110000
    //	x9       = _1111110 << 2 + _111
    //	i20      = x9 << 7 + _1111110
    //	i36      = i20 << 15 + i20
    //	i67      = i36 << 30 + i36
    //	x63      = i67 << 2 + _111
    //	i132     = x63 << 61 + i67
    //	x126     = i132 << 2 + _111
    //	i260     = x126 << 124 + i132
    //	x252     = i260 << 2 + _111
    //	x502     = x252 << 250 + i260 + 1
    //	return     (x502 << 4 + _111) << 6 + _101
    //
    var z = new(P512Element).Set(e)
    var t0 = new(P512Element)
    var t1 = new(P512Element)
    var t2 = new(P512Element)

    t0.Square(x)
    z.Square(t0)
    z.Mul(x, z)
    t0.Mul(t0, z)
    t1.Square(t0)
    t2.Square(t1)
    for s := 1; s < 3; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 2; s++ {
        t2.Square(t2)
    }
    t2.Mul(t0, t2)
    for s := 0; s < 7; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 15; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 30; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 2; s++ {
        t2.Square(t2)
    }
    t2.Mul(t0, t2)
    for s := 0; s < 61; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 2; s++ {
        t2.Square(t2)
    }
    t2.Mul(t0, t2)
    for s := 0; s < 124; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t2.Square(t1)
    for s := 1; s < 2; s++ {
        t2.Square(t2)
    }
    t2.Mul(t0, t2)
    for s := 0; s < 250; s++ {
        t2.Square(t2)
    }
    t1.Mul(t1, t2)
    t1.Mul(x, t1)
    for s := 0; s < 4; s++ {
        t1.Square(t1)
    }
    t0.Mul(t0, t1)
    for s := 0; s < 6; s++ {
        t0.Square(t0)
    }
    z.Mul(z, t0)
    return e.Set(z)
}
