// Code generated by generate.go. DO NOT EDIT.

package fiat

import (
    "crypto/subtle"
    "errors"
)

// P512Element is an integer modulo 2^512 - 569.
//
// The zero value is a valid zero element.
type P512Element struct {
    // Values are represented internally always in the Montgomery domain, and
    // converted in Bytes and SetBytes.
    x p512MontgomeryDomainFieldElement
}

const p512ElementLen = 64

type p512UntypedFieldElement = [8]uint64

// One sets e = 1, and returns e.
func (e *P512Element) One() *P512Element {
    p512SetOne(&e.x)
    return e
}

// Equal returns 1 if e == t, and zero otherwise.
func (e *P512Element) Equal(t *P512Element) int {
    eBytes := e.Bytes()
    tBytes := t.Bytes()
    return subtle.ConstantTimeCompare(eBytes, tBytes)
}

// IsZero returns 1 if e == 0, and zero otherwise.
func (e *P512Element) IsZero() int {
    zero := make([]byte, p512ElementLen)
    eBytes := e.Bytes()
    return subtle.ConstantTimeCompare(eBytes, zero)
}

// Set sets e = t, and returns e.
func (e *P512Element) Set(t *P512Element) *P512Element {
    e.x = t.x
    return e
}

// Bytes returns the 66-byte big-endian encoding of e.
func (e *P512Element) Bytes() []byte {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    var out [p512ElementLen]byte
    return e.bytes(&out)
}

func (e *P512Element) bytes(out *[p512ElementLen]byte) []byte {
    var tmp p512NonMontgomeryDomainFieldElement
    p512FromMontgomery(&tmp, &e.x)
    p512ToBytes(out, (*p512UntypedFieldElement)(&tmp))
    p512InvertEndianness(out[:])
    return out[:]
}

// SetBytes sets e = v, where v is a big-endian 66-byte encoding, and returns e.
// If v is not 66 bytes or it encodes a value higher than 2^512 - 569,
// SetBytes returns nil and an error, and e is unchanged.
func (e *P512Element) SetBytes(v []byte) (*P512Element, error) {
    if len(v) != p512ElementLen {
        return nil, errors.New("invalid P512Element encoding")
    }
    // Check for non-canonical encodings (p + k, 2p + k, etc.) by comparing to
    // the encoding of -1 mod p, so p - 1, the highest canonical encoding.
    var minusOneEncoding = new(P512Element).Sub(
        new(P512Element), new(P512Element).One()).Bytes()
    for i := range v {
        if v[i] < minusOneEncoding[i] {
            break
        }
        if v[i] > minusOneEncoding[i] {
            return nil, errors.New("invalid P512Element encoding")
        }
    }
    var in [p512ElementLen]byte
    copy(in[:], v)
    p512InvertEndianness(in[:])
    var tmp p512NonMontgomeryDomainFieldElement
    p512FromBytes((*p512UntypedFieldElement)(&tmp), &in)
    p512ToMontgomery(&e.x, &tmp)
    return e, nil
}

// Add sets e = t1 + t2, and returns e.
func (e *P512Element) Add(t1, t2 *P512Element) *P512Element {
    p512Add(&e.x, &t1.x, &t2.x)
    return e
}

// Sub sets e = t1 - t2, and returns e.
func (e *P512Element) Sub(t1, t2 *P512Element) *P512Element {
    p512Sub(&e.x, &t1.x, &t2.x)
    return e
}

// Mul sets e = t1 * t2, and returns e.
func (e *P512Element) Mul(t1, t2 *P512Element) *P512Element {
    p512Mul(&e.x, &t1.x, &t2.x)
    return e
}

// Square sets e = t * t, and returns e.
func (e *P512Element) Square(t *P512Element) *P512Element {
    p512Square(&e.x, &t.x)
    return e
}

// Select sets v to a if cond == 1, and to b if cond == 0.
func (v *P512Element) Select(a, b *P512Element, cond int) *P512Element {
    p512Selectznz((*p512UntypedFieldElement)(&v.x), p512Uint1(cond),
        (*p512UntypedFieldElement)(&b.x), (*p512UntypedFieldElement)(&a.x))
    return v
}

func p512InvertEndianness(v []byte) {
    for i := 0; i < len(v)/2; i++ {
        v[i], v[len(v)-1-i] = v[len(v)-1-i], v[i]
    }
}
